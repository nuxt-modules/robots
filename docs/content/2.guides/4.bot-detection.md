---
title: Bot Detection
description: Detect and classify bots with server-side header analysis and client-side browser fingerprinting.
---

## Introduction

Bot detection helps you identify automated traffic to better understand your visitors and optimize your site's behavior for different user types.

The module provides comprehensive bot detection that works on both server and client side, identifying everything from search engine crawlers to malicious automation tools.

**ðŸ”” Important:** Bot detection is entirely opt-in and only works when you explicitly use the provided utilities or composables. No bot detection runs automatically - you must call the functions or use the composables to enable it.

## Getting Started

To enable bot detection, you have two options:

1. **Use the `useBotDetection()` composable** in your Vue components for reactive bot detection
2. **Use the server utilities** (`getBotDetection`, `isBot`, `getBotInfo`) in your server routes, middleware, or API handlers

Without using these functions, no bot detection will occur.

## Basic Usage

The `useBotDetection()` composable provides reactive access to bot detection results:

```vue
<script setup>
const { isBot, botInfo } = useBotDetection()
</script>

<template>
  <div v-if="isBot">
    Bot detected: {{ botInfo?.name }}
  </div>
  <div v-else>
    Human visitor
  </div>
</template>
```

## Detection Methods

### Server-side Detection (Manual Only)

Analyzes HTTP headers and user agents to identify known bots when you call the detection utilities:

- Search engines (Google, Bing, Yandex)
- Social media crawlers (Twitter, Facebook)
- SEO tools (Ahrefs, SEMrush)
- AI crawlers (GPT, Claude)
- Security scanners and automation tools

This detection is lightweight and only runs when you explicitly call the detection functions or use the `useBotDetection()` composable.

### Client-side Fingerprinting (Opt-in)

Uses @fingerprintjs/botd to detect advanced automation tools:

- Headless browsers (Chrome, Firefox)
- Automation frameworks (Selenium, Playwright)
- Bot detection tools (PhantomJS, Nightmare)
- Cached results for performance

**Note:** Client-side fingerprinting is disabled by default due to performance costs. Enable it explicitly when needed.

## Watching Changes

Bot detection state is reactive and can be watched for changes:

```ts
import { watch } from 'vue'

const { isBot, botInfo } = useBotDetection()

watch(isBot, (detected) => {
  if (detected) {
    console.log(`Bot detected: ${botInfo.value?.name}`)
  }
})
```

## Bot Classification

Detected bots are classified by type and trust level:

```ts
const { botInfo } = useBotDetection()

if (botInfo.value) {
  console.log(botInfo.value.type) // 'search-engine', 'social', 'ai', etc.
  console.log(botInfo.value.trusted) // true for legitimate bots
  console.log(botInfo.value.method) // 'server' or 'fingerprint'
}
```

## Server-side Usage

### In Nitro Routes and Middleware

Use the provided server composables:

```ts
// server/api/example.ts
import { getBotDetection, getBotInfo, isBot } from '@nuxtjs/robots/nitro'

export default defineEventHandler(async (event) => {
  // Simple boolean check
  if (isBot(event)) {
    return { message: 'Bot detected' }
  }

  // Get detailed info
  const botInfo = getBotInfo(event)
  if (botInfo?.trusted) {
    return { message: 'Trusted bot', bot: botInfo.name }
  }

  return { message: 'Human user' }
})
```

### Manual Header Analysis

For custom header analysis with pure utility functions:

```ts
import { getBotDetection, getBotInfo, isBot } from '@nuxtjs/robots/util'

const headers = getHeaders(event)

// Complete detection context
const detection = getBotDetection(headers)

// Simple boolean check
if (isBot(headers)) {
  console.log('Bot detected!')
}

// Detailed bot info
const botInfo = getBotInfo(headers)
if (botInfo) {
  console.log(`Bot: ${botInfo.name} (${botInfo.type})`)
}
```

**Note:** These pure utility functions work with any headers object and can be used in any JavaScript environment.

## Nuxt Hooks

The module fires hooks for fingerprinting events:

```ts
// nuxt.config.ts
export default defineNuxtConfig({
  hooks: {
    'robots:fingerprinting:bot-detected': (data) => {
      console.log('Fingerprinting detected bot:', data.result.botName)
      console.log('User Agent:', data.result.userAgent)
      console.log('Raw fingerprint data:', data.fingerprint)
      // data.fingerprint contains the full result from @fingerprintjs/botd
    },
    'robots:fingerprinting:error': (data) => {
      console.error('Fingerprinting error:', data.error)
    }
  }
})
```

**Note:** These hooks only fire for client-side fingerprinting detection, not server-side header analysis.

## Disabling Bot Detection

You can disable the entire bot detection plugin:

```ts
// nuxt.config.ts
export default defineNuxtConfig({
  robots: {
    botDetection: false // Disables the entire plugin
  }
})
```

## Client-side Fingerprinting

Client-side fingerprinting is always manual to avoid performance costs:

```vue
<script setup>
const { isBot, enableFingerprinting } = useBotDetection()

// Trigger fingerprinting when needed
async function checkForAdvancedBots() {
  const result = await enableFingerprinting()

  if (result) {
    // Bot detected via fingerprinting
    console.log('Advanced bot detected:', result.botName)
    console.log('Bot type:', result.botType)
    console.log('Trusted:', result.trusted)
  }
  else {
    console.log('No advanced bot detected')
  }
}
</script>

<template>
  <div>
    <p v-if="isBot">
      Server detected bot: {{ botInfo?.name }}
    </p>
    <button @click="checkForAdvancedBots">
      Run Advanced Detection
    </button>
  </div>
</template>
```

## Performance

- **Server detection**: Lightweight header analysis with minimal overhead (manual only)
- **Client fingerprinting**: More comprehensive but expensive detection (opt-in only)
- **Caching**: Results persist in localStorage to avoid repeated expensive checks
- **Optimization**: Fingerprinting skipped if server already detected a bot
- **Binary decision**: Either definitively a bot or not detected
